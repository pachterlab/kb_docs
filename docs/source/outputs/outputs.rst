.. _kb-outputs:

=====================================
Interpreting Quality and Run Information in kb-python
=====================================

When you run the ``kb`` command, the pipeline generates several metadata
files that record provenance, tool versions, command parameters, and
basic quality metrics. These files are useful both for validating
that your run executed correctly and for checking the quality of your
sequencing data.

This page explains three important JSON outputs:

* ``run_info.json`` — generated by *kallisto*
* ``inspect.json`` — generated by *bustools*
* ``kb_info.json`` — generated by *kb-python* itself

These files allow users to verify:

* whether the pipeline executed the correct workflow and chemistry
* whether input FASTQs are intact
* whether alignment performed as expected
* whether barcodes and UMIs appear valid
* the exact commands and tool versions used for reproducibility

-------------------------------------
``run_info.json`` — Kallisto Summary
-------------------------------------

``run_info.json`` is generated by ``kallisto`` during pseudoalignment.
It summarizes how many reads were processed, how many pseudoaligned,
and which index and version were used.

Typical contents::

    {
      "n_targets": 86288,
      "n_bootstraps": 0,
      "n_processed": 13456789,
      "n_pseudoaligned": 12034567,
      "p_pseudoaligned": 89.4,
      "p_unique": 24.4,
      "kallisto_version": "0.51.1",
      "index_version": 11,
      "index_kmer_length": 31,
      "start_time": "...",
      "call": "kallisto bus ..."
    }

Key fields
==========

.. list-table::
   :widths: 20 30 50
   :header-rows: 1

   * - Field
     - Description
     - What to check
   * - ``n_targets``
     - Number of transcript targets in the index
     - Matches expected transcriptome build
   * - ``n_processed``
     - Total reads processed
     - Roughly equals FASTQ read count
   * - ``n_pseudoaligned``
     - Reads that pseudoaligned to the reference
     - Much lower than expected → low quality or wrong index
   * - ``p_pseudoaligned``
     - Percent of reads pseudoaligned
     - Good data often >60–70%
   * - ``p_unique``
     - Percent of reads mapping uniquely to one target
     - < 20% may indicate low library complexity or poor quality reads
   * - ``call``
     - Full kallisto invocation
     - Confirms correct parameters were used

Signs of potential problems
===========================

* ``p_pseudoaligned`` < 40% (often wrong index, chemistry mismatch, or
  poor-quality reads)
* ``n_processed`` far below expected FASTQ size (truncated or corrupted
  FASTQs)
* ``index_version`` incompatible with ``kallisto`` version

-------------------------------------
``inspect.json`` — bustools `inspect` summary
-------------------------------------

``inspect.json`` is produced by ``bustools inspect`` and provides aggregate
statistics about the BUS file: how many BUS records and reads are present,
how many distinct barcodes and UMIs were observed, summaries of reads-per-barcode
and UMIs-per-barcode, and how many barcodes/reads match the supplied onlist. 
Below is an example snippet and a field-by-field explanation.

Example (abridged) contents::

    {
      "numRecords": 117354584,
      "numReads": 507909041,
      "numBarcodes": 3904019,
      "medianReadsPerBarcode": 3.000000,
      "meanReadsPerBarcode": 130.099019,
      "numUMIs": 16529783,
      "numBarcodeUMIs": 96095799,
      "medianUMIsPerBarcode": 1.000000,
      "meanUMIsPerBarcode": 24.614583,
      "gtRecords": 28752978,
      "numBarcodesOnOnlist": 1138841,
      "percentageBarcodesOnOnlist": 29.170990,
      "numReadsOnOnlist": 488498272,
      "percentageReadsOnOnlist": 96.178298
    }

Field definitions and interpretation
====================================

.. list-table::
   :widths: 20 40 40
   :header-rows: 1

   * - Field
     - What it reports
     - How to interpret / check
   * - ``numRecords``
     - Total number of BUS records inspected by ``bustools inspect``.
     - A BUS record typically corresponds to a pseudoaligned record in the
       BUS file. Use this to sanity-check that the BUS file is not empty.
   * - ``numReads``
     - The total number of raw reads represented by those BUS records.
     - Should be close to the total number of input reads (or read pairs)
       after any technology-specific collapsing. Large discrepancies can
       indicate truncated or mispaired FASTQs or an incorrect kallisto run.
   * - ``numBarcodes``
     - Number of distinct barcodes observed in the BUS file.
     - Compare to expected cell barcode space (e.g., ~million for high-throughput
       experiments). Very low values may indicate a chemistry mismatch.
   * - ``medianReadsPerBarcode``
     - The median number of reads assigned to a barcode (across all barcodes).
     - Useful to see the typical sequencing depth per barcode. Median is robust
       to very-high-depth barcode outliers.
   * - ``meanReadsPerBarcode``
     - The average number of reads per barcode.
     - If mean ≫ median, a few barcodes have extremely high read counts; that
       may be expected (ambient RNA, multiplets) or indicate problems.
   * - ``numUMIs``
     - Count of distinct UMI sequences observed (unique UMIs aggregated across file).
     - Lower-than-expected values can indicate short/low-quality UMIs or wrong
       chemistry parameters.
   * - ``numBarcodeUMIs``
     - Count of distinct barcode+UMI pairs observed (i.e., unique (barcode, UMI)
       combinations across the file).
     - This is typically larger than ``numUMIs`` because each UMI can appear
       under multiple barcodes; use both fields to understand complexity.
   * - ``medianUMIsPerBarcode``
     - Median number of unique UMIs observed per barcode.
     - Typical values depend heavily on protocol and sequencing depth; single-cell
       libraries often have low medians (1–10) for shallow sequencing runs.
   * - ``meanUMIsPerBarcode``
     - Average number of unique UMIs per barcode.
     - As with reads, if mean ≫ median, a small set of barcodes carries most UMIs.
   * - ``gtRecords``
     - Number of BUS records with a valid gene/transcript assignment (i.e., record
       maps to a transcript/gene in the index) — records that contribute to gene-level signals.
     - Use to estimate how many records will be useful for downstream counting.
   * - ``numBarcodesOnOnlist``
     - Number of observed barcodes that are present in the provided whitelist
       (the “on-list” / official barcode list for the technology).
     - This indicates how many barcodes match the expected barcode set.
   * - ``percentageBarcodesOnOnlist``
     - Fraction of observed barcodes that are on-list (percent).
     - For 10x-style experiments a substantial fraction of reads should be on-list,
       but the fraction of *distinct observed barcodes* on the whitelist can be
       lower because many sequencing errors create unique off-list barcodes.
   * - ``numReadsOnOnlist``
     - Number of reads whose barcode is on the whitelist.
     - This is often the most informative single metric: high percentage (e.g.
       > 80–90%) indicates that most reads came from legitimate barcodes.
   * - ``percentageReadsOnOnlist``
     - Fraction of reads whose barcode is on the whitelist (percent).
     - High values are expected for correctly-specified chemistry and high-quality data.

Practical checks and recommendations
====================================

* **Sanity-check sizes**: ``numReads`` and ``numRecords`` should be large and in the
  ballpark of what you expect from your input FASTQs and from the kallisto run.
  If either is very small, check that kallisto succeeded and that FASTQs are intact.

* **onlist checks**:
  * Prefer checking ``percentageReadsOnOnlist`` first: if a large majority
    of reads are onlist (e.g., **>80%**), the barcode whitelist was likely
    correct and most reads are assignable to expected barcodes.
  * If ``percentageReadsOnOnlist`` is high but ``percentageBarcodesOnOnlist`` is
    low, that usually means many low-frequency erroneous barcodes exist (normal).
  * If both read- and barcode-level on-list percentages are low → verify
    the ``--technology`` onlist used with kallisto/bustools.

* **Reads/UMI per barcode**:
  * Compare median vs mean. If mean ≫ median this indicates heavy skew:
    a few barcodes hold many reads/UMIs (possible multiplets, ambient RNA, or
    barcode collisions).
  * Very low medians (e.g., medians near 1) indicate shallow sequencing per
    barcode — that could be expected for some experimental designs.

* **UMI / barcodeUMI counts**:
  * ``numBarcodeUMIs`` >> ``numUMIs`` is expected: the same UMI sequence may
    occur across many barcodes; what matters for per-cell counting is the
    per-barcode UMI distribution (e.g., ``medianUMIsPerBarcode``).

* **gtRecords**:
  * If ``gtRecords`` is much smaller than ``numRecords`` (i.e., most records do
    not map to transcripts/genes), this may indicate an index mismatch or
    incorrect reference (kallisto index). Confirm that the index matches the
    species/annotation used for your reads.

Troubleshooting guidance
========================

* **Low ``percentageReadsOnOnlist``**  
  * Check that you supplied the correct technology/whitelist (``--technology``).
  * Verify that the whitelist file provided matches the barcodes present in
    your experiment (custom chemistry needs a custom whitelist).

* **Very low ``numReads`` or ``numRecords``**  
  * Confirm kallisto completed without errors (look at ``run_info.json`` and
    kallisto logs).
  * Inspect input FASTQs for truncation or missing pairs.

* **Extreme skew in mean vs median**  
  * A small set of barcodes dominating reads may be multiplets or barcode
    synthesis artifacts. Consider additional filtering, ambient RNA correction,
    or multiplet detection in downstream analysis.

-------------------------------------
``kb_info.json`` — kb-python run provenance and runtime
-------------------------------------

``kb_info.json`` is produced by ``kb`` (``kb-python``) and records run-level
provenance, tool versions, the exact commands executed, timing information,
and per-step runtimes. It is the authoritative record of *how* the pipeline
was run and is essential for reproducibility and diagnosing pipeline problems.

Example::

    {
        "workdir": "/home/.../",
        "version": "0.29.3",
        "kallisto": {
            "path": "/.../kallisto",
            "version": "0.51.1"
        },
        "bustools": {
            "path": "/.../bustools",
            "version": "0.45.0"
        },
        "start_time": "2025-10-20T18:31:59.761408",
        "end_time": "2025-10-20T19:48:38.041715",
        "elapsed": 4598.280307,
        "call": "/home/.../kb count --overwrite --h5ad -i index.idx -g t2g.txt -x 10XV3 -o ... --workflow=nac -c1 cdna.txt -c2 nascent.txt ...",
        "commands": [
            "kallisto bus -i index.idx -o ... -x 10XV3 -t 16 ...",
            "bustools sort -o ... -T ... -t 16 -m 4G ...",
            "bustools inspect -o ... -w 10x_version3_whitelist.txt ...",
            "bustools correct -o ... -w 10x_version3_whitelist.txt ...",
            "bustools sort -o ... -T ... -t 16 -m 4G ...",
            "bustools count -o ... -g t2g.txt -e ... -t ... -s nascent.txt --genecounts --umi-gene ..."
        ],
        "runtimes": [
            4194.1722021102905,
            105.48708367347717,
            35.703389406204224,
            44.34646153450012,
            31.489474534988403,
            163.7225775718689
        ]
    }

Field-by-field explanation
==========================

.. list-table::
   :widths: 20 40 40
   :header-rows: 1

   * - Field
     - What it reports
     - How to interpret / check
   * - ``workdir``
     - The working directory used for the run.
     - Confirm outputs are located where you expect; relative paths in ``commands``
       are resolved from here.
   * - ``version``
     - The kb-python release version used.
     - Important for reproducibility; record this with your run artifacts.
   * - ``kallisto`` / ``bustools`` (objects)
     - Each contains ``path`` and ``version`` for the binary used.
     - Verify these versions are appropriate for your index/commands and that the
       paths point to the intended binaries (conda env, system install, or bundled).
   * - ``start_time`` / ``end_time``
     - ISO timestamps for run start and finish.
     - Useful for human-readable audit logs and correlating with cluster logs.
   * - ``elapsed``
     - Total elapsed time for the entire kb run (seconds).
     - Should be roughly the sum of heavy step runtimes; extremely small values
       indicate early termination, very large values may indicate resource stalls.
   * - ``call``
     - The full ``kb`` command-line invocation that produced the run.
     - Check this to confirm flags like ``--workflow``, ``-x/--technology``, ``-i``,
       ``-g``, any custom ``-c`` files, and output paths.
   * - ``commands``
     - Array of the exact tool commands executed in order (kallisto, bustools steps, etc.).
     - Use to check each step invoked the expected arguments (e.g., whitelist,
       correct -x string, correct -t threads, memory flags).
   * - ``runtimes``
     - Per-command runtime (seconds) aligned with the same index positions in ``commands``.
     - Compare runtimes to expectations (e.g., kallisto bus usually dominates).
       Unusually short runtimes can indicate command failure; extremely long ones
       can indicate I/O bottlenecks or insufficient memory causing swapping.


-----------------------------
Checklist for Successful Runs
-----------------------------

Use the following as a quick verification workflow:

#. **Check kallisto alignment quality** using ``run_info.json``:
   * ``p_pseudoaligned`` in expected range
   * ``n_processed`` matches FASTQ size

#. **Check barcode/UMI integrity** using ``inspect.json``:
   * Majority of reads on-list
   * Barcode/UMI lengths match the chemistry

#. **Confirm pipeline parameters** using ``kb_info.json``:
   * Correct workflow (``standard`` / ``lamanno`` / ``nac``)
   * Correct technology (``10xv2`` / ``10xv3`` / custom)
   * Correct references and t2g file
   * Commands match expected configuration

#. **Archive all three JSON files** for reproducibility.

-------------------------------------
Troubleshooting Common Problems
-------------------------------------

* **Low pseudoalignment rate**  
  Usually wrong transcriptome index or poor read quality.

* **Barcode structure mismatches**  
  Often caused by incorrect ``--technology`` argument.

* **Missing or empty output files**  
  Indicates truncated FASTQs, corrupted BUS file, or interrupted run.

* **Inconsistent reference versions**  
  Verify that all reference files were generated together using
  ``kb ref``.

-------------------------------------

These output files provide you with everything needed to ensure that
``kb-python`` ran correctly and that your data exhibit expected
structure and quality. Users are strongly encouraged to inspect all
three files before proceeding to downstream analysis.

